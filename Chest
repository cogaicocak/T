
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

-- Variables
local LocalPlayer = Players.LocalPlayer

-- Teleport Configuration
local NEXT_PLACE_ID = 100117331123089
local NoChestTime = 0
local NoChestThreshold = 3
local HasTeleported = false
local RetryDelay = 0.5
local CurrentServerId = game.JobId -- L∆∞u server hi·ªán t·∫°i
local TriedServers = {[game.JobId] = true} -- Danh s√°ch server ƒë√£ th·ª≠ (bao g·ªìm server hi·ªán t·∫°i)

-- Chest Timeout Configuration
local CurrentChest = nil
local ChestStuckTime = 0
local ChestTimeoutThreshold = 5
local CollectedChests = {}

local function getCharacter()
	if not LocalPlayer.Character then
		LocalPlayer.CharacterAdded:Wait()
	end
	LocalPlayer.Character:WaitForChild("HumanoidRootPart")
	return LocalPlayer.Character
end

-- Create GUI
local function createGui()
	local oldGui = LocalPlayer.PlayerGui:FindFirstChild("ChestFarmGUI")
	if oldGui then
		oldGui:Destroy()
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = "ChestFarmGUI"
	gui.IgnoreGuiInset = true
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.DisplayOrder = 999999
	gui.ResetOnSpawn = false
	gui.Parent = LocalPlayer.PlayerGui

	local background = Instance.new("Frame")
	background.Name = "Background"
	background.Parent = gui
	background.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
	background.BackgroundTransparency = 1
	background.Size = UDim2.new(1, 0, 1, 0)
	background.Position = UDim2.new(0, 0, 0, 0)
	background.BorderSizePixel = 0

	local container = Instance.new("Frame")
	container.Name = "Container"
	container.Parent = background
	container.Size = UDim2.new(0, 500, 0, 200)
	container.Position = UDim2.new(0.5, 0, 0.5, 0)
	container.AnchorPoint = Vector2.new(0.5, 0.5)
	container.BackgroundTransparency = 1

	local glowFrame = Instance.new("Frame")
	glowFrame.Name = "GlowFrame"
	glowFrame.Parent = container
	glowFrame.Size = UDim2.new(1, 40, 1, 40)
	glowFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	glowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	glowFrame.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
	glowFrame.BackgroundTransparency = 1
	glowFrame.ZIndex = 0

	local glowCorner = Instance.new("UICorner")
	glowCorner.CornerRadius = UDim.new(0, 20)
	glowCorner.Parent = glowFrame

	local contentFrame = Instance.new("Frame")
	contentFrame.Name = "ContentFrame"
	contentFrame.Parent = container
	contentFrame.Size = UDim2.new(1, 0, 1, 0)
	contentFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	contentFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	contentFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 18)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ZIndex = 1

	local contentCorner = Instance.new("UICorner")
	contentCorner.CornerRadius = UDim.new(0, 15)
	contentCorner.Parent = contentFrame

	local borderStroke = Instance.new("UIStroke")
	borderStroke.Color = Color3.fromRGB(70, 70, 70)
	borderStroke.Thickness = 1
	borderStroke.Transparency = 1
	borderStroke.Parent = contentFrame

	local topLine = Instance.new("Frame")
	topLine.Name = "TopLine"
	topLine.Parent = contentFrame
	topLine.Size = UDim2.new(0, 0, 0, 2)
	topLine.Position = UDim2.new(0.5, 0, 0.15, 0)
	topLine.AnchorPoint = Vector2.new(0.5, 0.5)
	topLine.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
	topLine.BorderSizePixel = 0
	topLine.ZIndex = 3

	local topGradient = Instance.new("UIGradient")
	topGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 50, 50)),
		ColorSequenceKeypoint.new(0.5, Color3.fromRGB(180, 180, 180)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
	})
	topGradient.Parent = topLine

	local mainText = Instance.new("TextLabel")
	mainText.Name = "MainText"
	mainText.Parent = contentFrame
	mainText.Size = UDim2.new(0.9, 0, 0.5, 0)
	mainText.Position = UDim2.new(0.5, 0, 0.38, 0)
	mainText.AnchorPoint = Vector2.new(0.5, 0.5)
	mainText.BackgroundTransparency = 1
	mainText.Text = "Thon Hub"
	mainText.TextColor3 = Color3.fromRGB(240, 240, 240)
	mainText.TextSize = 42
	mainText.Font = Enum.Font.GothamBold
	mainText.TextTransparency = 1
	mainText.TextXAlignment = Enum.TextXAlignment.Center
	mainText.TextYAlignment = Enum.TextYAlignment.Center
	mainText.ZIndex = 3

	local shadowText = Instance.new("TextLabel")
	shadowText.Name = "ShadowText"
	shadowText.Parent = contentFrame
	shadowText.Size = mainText.Size
	shadowText.Position = UDim2.new(0.5, 2, 0.38, 2)
	shadowText.AnchorPoint = Vector2.new(0.5, 0.5)
	shadowText.BackgroundTransparency = 1
	shadowText.Text = mainText.Text
	shadowText.TextColor3 = Color3.fromRGB(0, 0, 0)
	shadowText.TextSize = mainText.TextSize
	shadowText.Font = mainText.Font
	shadowText.TextTransparency = 1
	shadowText.TextXAlignment = Enum.TextXAlignment.Center
	shadowText.TextYAlignment = Enum.TextYAlignment.Center
	shadowText.ZIndex = 2

	local creditText = Instance.new("TextLabel")
	creditText.Name = "CreditText"
	creditText.Parent = contentFrame
	creditText.Size = UDim2.new(0.9, 0, 0.3, 0)
	creditText.Position = UDim2.new(0.5, 0, 0.7, 0)
	creditText.AnchorPoint = Vector2.new(0.5, 0.5)
	creditText.BackgroundTransparency = 1
	creditText.Text = '"TrƒÉng kia ai n·∫∑n m√† tr√≤n, l·ªìn em ai ƒë·ªãt m√† m√≤n m·ªôt b√™n"'
	creditText.TextColor3 = Color3.fromRGB(150, 150, 150)
	creditText.TextSize = 20
	creditText.Font = Enum.Font.Gotham
	creditText.TextTransparency = 1
	creditText.TextXAlignment = Enum.TextXAlignment.Center
	creditText.TextYAlignment = Enum.TextYAlignment.Center
	creditText.ZIndex = 3

	local dotsContainer = Instance.new("Frame")
	dotsContainer.Name = "DotsContainer"
	dotsContainer.Parent = contentFrame
	dotsContainer.Size = UDim2.new(0.2, 0, 0.05, 0)
	dotsContainer.Position = UDim2.new(0.5, 0, 0.88, 0)
	dotsContainer.AnchorPoint = Vector2.new(0.5, 0.5)
	dotsContainer.BackgroundTransparency = 1
	dotsContainer.ZIndex = 3

	for i = 1, 3 do
		local dot = Instance.new("Frame")
		dot.Name = "Dot" .. i
		dot.Parent = dotsContainer
		dot.Size = UDim2.new(0, 6, 0, 6)
		dot.Position = UDim2.new((i - 1) * 0.4 + 0.1, 0, 0.5, 0)
		dot.AnchorPoint = Vector2.new(0.5, 0.5)
		dot.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
		dot.BorderSizePixel = 0
		dot.BackgroundTransparency = 1

		local dotCorner = Instance.new("UICorner")
		dotCorner.CornerRadius = UDim.new(1, 0)
		dotCorner.Parent = dot
	end

	-- Animations
	task.spawn(function()
		local fadeInfo = TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		TweenService:Create(background, fadeInfo, { BackgroundTransparency = 0.4 }):Play()
		TweenService:Create(contentFrame, fadeInfo, { BackgroundTransparency = 0.05 }):Play()
		TweenService:Create(borderStroke, fadeInfo, { Transparency = 0.6 }):Play()
		task.wait(0.3)
		TweenService:Create(mainText, fadeInfo, { TextTransparency = 0 }):Play()
		TweenService:Create(shadowText, fadeInfo, { TextTransparency = 0.8 }):Play()
		task.wait(0.2)
		TweenService:Create(creditText, fadeInfo, { TextTransparency = 0.4 }):Play()
	end)

	task.spawn(function()
		task.wait(1)
		while glowFrame and glowFrame.Parent do
			TweenService:Create(glowFrame, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { BackgroundTransparency = 0.9 }):Play()
			task.wait(3)
			TweenService:Create(glowFrame, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { BackgroundTransparency = 1 }):Play()
			task.wait(3)
		end
	end)

	task.spawn(function()
		task.wait(0.8)
		TweenService:Create(topLine, TweenInfo.new(1.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Size = UDim2.new(0.6, 0, 0, 2) }):Play()
		task.wait(1.5)
		while topGradient and topGradient.Parent do
			local flow = TweenService:Create(topGradient, TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), { Offset = Vector2.new(1, 0) })
			flow:Play()
			flow.Completed:Wait()
			topGradient.Offset = Vector2.new(-1, 0)
		end
	end)

	task.spawn(function()
		task.wait(2)
		while mainText and mainText.Parent do
			TweenService:Create(mainText, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { TextColor3 = Color3.fromRGB(200, 200, 200) }):Play()
			task.wait(4)
			TweenService:Create(mainText, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { TextColor3 = Color3.fromRGB(240, 240, 240) }):Play()
			task.wait(4)
		end
	end)

	task.spawn(function()
		task.wait(1.5)
		local dots = dotsContainer:GetChildren()
		while dotsContainer and dotsContainer.Parent do
			for _, dot in ipairs(dots) do
				if dot:IsA("Frame") then
					TweenService:Create(dot, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { BackgroundTransparency = 0.3 }):Play()
					task.wait(0.15)
				end
			end
			task.wait(0.3)
			for _, dot in ipairs(dots) do
				if dot:IsA("Frame") then
					TweenService:Create(dot, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { BackgroundTransparency = 1 }):Play()
				end
			end
			task.wait(1)
		end
	end)

	task.spawn(function()
		task.wait(2.5)
		while borderStroke and borderStroke.Parent do
			TweenService:Create(borderStroke, TweenInfo.new(5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { Color = Color3.fromRGB(100, 100, 100), Transparency = 0.4 }):Play()
			task.wait(5)
			TweenService:Create(borderStroke, TweenInfo.new(5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { Color = Color3.fromRGB(70, 70, 70), Transparency = 0.6 }):Play()
			task.wait(5)
		end
	end)

	task.spawn(function()
		task.wait(3)
		while creditText and creditText.Parent do
			TweenService:Create(creditText, TweenInfo.new(6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { TextTransparency = 0.7 }):Play()
			task.wait(6)
			TweenService:Create(creditText, TweenInfo.new(6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), { TextTransparency = 0.4 }):Play()
			task.wait(6)
		end
	end)

	return gui, mainText
end

-- üÜï T√¨m server m·ªõi kh√¥ng tr√πng server ƒë√£ th·ª≠
local function findAndTeleportNewServer()
	task.spawn(function()
		local attemptCount = 0
		
		while true do
			attemptCount = attemptCount + 1
			
			local success, result = pcall(function()
				-- L·∫•y danh s√°ch server qua API Roblox
				local response = HttpService:JSONDecode(
					game:HttpGet("https://games.roblox.com/v1/games/" .. NEXT_PLACE_ID .. "/servers/Public?sortOrder=Asc&limit=100")
				)
				
				if response and response.data then
					-- L·ªçc ra server ch∆∞a th·ª≠
					local validServers = {}
					for _, server in ipairs(response.data) do
						if not TriedServers[server.id] and server.playing < server.maxPlayers then
							table.insert(validServers, server)
						end
					end
					
					if #validServers > 0 then
						-- Ch·ªçn server ng·∫´u nhi√™n t·ª´ danh s√°ch h·ª£p l·ªá
						local chosenServer = validServers[math.random(1, #validServers)]
						
						-- ƒê√°nh d·∫•u server n√†y ƒë√£ th·ª≠
						TriedServers[chosenServer.id] = true
						
						
						-- Teleport ƒë·∫øn server c·ª• th·ªÉ ƒë√≥
						TeleportService:TeleportToPlaceInstance(NEXT_PLACE_ID, chosenServer.id, LocalPlayer)
					else
					end
				end
			end)
			
			if not success then
				-- Fallback: d√πng teleport th∆∞·ªùng n·∫øu API fail
				pcall(function()
					TeleportService:Teleport(NEXT_PLACE_ID, LocalPlayer)
				end)
			end
			
			task.wait(RetryDelay)
		end
	end)
end

-- Teleport to next place
local function TeleportToNextPlace()
	if HasTeleported then return end
	HasTeleported = true
	
	findAndTeleportNewServer()
end

-- Auto Reconnect
local function setupAutoReconnect()
	game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(prompt)
		if prompt.Name == "ErrorPrompt" or prompt.Name == "ConnectionErrorPrompt" then
			task.wait(RetryDelay)
			findAndTeleportNewServer()
		end
	end)
	
	TeleportService.TeleportInitFailed:Connect(function(player, result, errorMessage)
		HasTeleported = false
		TeleportToNextPlace()
	end)
end

-- Check if chest is collected
local function isChestCollected(chest)
	for _, collectedChest in ipairs(CollectedChests) do
		if collectedChest == chest then
			return true
		end
	end
	return false
end

-- Mark chest as collected
local function markChestAsCollected(chest)
	if not isChestCollected(chest) then
		table.insert(CollectedChests, chest)
	end
end

-- Chest detection
local UncheckedChests, FirstRun = {}, true
local function getChestsSorted()
	if FirstRun then
		FirstRun = false
		for _, Object in pairs(game:GetDescendants()) do
			if Object.Name:find("Chest") and Object.ClassName == "Part" then
				table.insert(UncheckedChests, Object)
			end
		end
	end

	local Chests = {}
	for _, Chest in pairs(UncheckedChests) do
		if Chest:FindFirstChild("TouchInterest") and not isChestCollected(Chest) then
			table.insert(Chests, Chest)
		end
	end

	pcall(function()
		local RootPart = getCharacter().HumanoidRootPart
		table.sort(Chests, function(ChestA, ChestB)
			local RootPos = RootPart.Position
			local DistanceA = (RootPos - ChestA.Position).Magnitude
			local DistanceB = (RootPos - ChestB.Position).Magnitude
			return DistanceA < DistanceB
		end)
	end)

	return Chests
end

-- Noclip toggle
local function toggleNoclip(Toggle)
	pcall(function()
		for _, v in pairs(getCharacter():GetChildren()) do
			if v:IsA("BasePart") then
				v.CanCollide = not Toggle
			end
		end
	end)
end

-- Teleport to chest
local function Teleport(Goal)
	pcall(function()
		local RootPart = getCharacter().HumanoidRootPart
		toggleNoclip(true)
		RootPart.CFrame = Goal + Vector3.new(0, 3, 0)
		toggleNoclip(false)
	end)
end

-- Main farm loop
local function startFarm()
	task.spawn(function()
		while task.wait() do
			pcall(function()
				local Chests = getChestsSorted()

				if #Chests > 0 then
					NoChestTime = 0
					local targetChest = Chests[1]

					if CurrentChest == targetChest then
						ChestStuckTime = ChestStuckTime + 0.03

						if ChestStuckTime >= ChestTimeoutThreshold then
							markChestAsCollected(targetChest)
							CurrentChest = nil
							ChestStuckTime = 0
							return
						end
					else
						CurrentChest = targetChest
						ChestStuckTime = 0
					end

					Teleport(targetChest.CFrame)
				else
					NoChestTime = NoChestTime + 0.03
					CurrentChest = nil
					ChestStuckTime = 0

					if NoChestTime >= NoChestThreshold then
						TeleportToNextPlace()
					end
				end
			end)
		end
	end)
end

-- Auto Marines
task.spawn(function()
	local rs = ReplicatedStorage
	while task.wait(5) do
		pcall(function()
			rs.Remotes.CommF_:InvokeServer("SetTeam", "Marines")
		end)
	end
end)

-- Character respawn
LocalPlayer.CharacterAdded:Connect(function()
	task.wait(1)
	NoChestTime = 0
	HasTeleported = false
	CurrentChest = nil
	ChestStuckTime = 0
	pcall(startFarm)
end)

-- Initialize
pcall(function()
	createGui()
	setupAutoReconnect()
	startFarm()
end)
